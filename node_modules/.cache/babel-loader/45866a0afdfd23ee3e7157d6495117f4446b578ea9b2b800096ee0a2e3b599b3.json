{"ast":null,"code":"var _jsxFileName = \"E:\\\\project\\\\duckling-game\\\\src\\\\components\\\\GameBoard.js\",\n  _s = $RefreshSig$();\n// src/components/GameBoard.js\n\nimport React, { useState, useEffect, useRef, useMemo } from 'react';\nimport './GameBoard.css';\nimport Duckling from './Duckling';\nimport MCQModal from './MCQModal';\nimport { questions } from '../data/questions'; // Ensure this path is correct\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GameBoard = ({\n  setScore,\n  setLives,\n  setCoins,\n  score,\n  lives,\n  coins,\n  onGameOver // New prop to handle game over\n}) => {\n  _s();\n  const gameBoardRef = useRef(null);\n\n  // Duckling position states\n  const [leftPosition, setLeftPosition] = useState(50); // Initial left position in px\n  const [isJumping, setIsJumping] = useState(false);\n  const [facingLeft, setFacingLeft] = useState(false); // To handle orientation\n  const [isPaused, setIsPaused] = useState(false); // New state to control pause\n  const forwardSpeed = 2; // Continuous forward movement speed\n  const moveSpeed = 5; // Pixels to move per interval\n  const jumpDuration = 600; // Total jump duration in ms\n\n  // MCQ Modal states\n  const [showMCQ, setShowMCQ] = useState(false);\n  const [currentQuestion, setCurrentQuestion] = useState(null);\n  const [duckOnRed, setDuckOnRed] = useState(false);\n\n  // Key press state\n  const keysPressed = useRef({});\n\n  // Memoize blocks to prevent re-creation on every render\n  const blocks = useMemo(() => {\n    const totalBlocks = 20; // Number of blocks on the platform\n    return Array.from({\n      length: totalBlocks\n    }).map((_, index) => ({\n      type: [4, 9, 14, 19].includes(index) ? 'red' : 'blue',\n      x: index * 80,\n      // blockWidth is 80px as per CSS\n      y: 0,\n      // Platforms are at y=0 relative to game board\n      width: 80,\n      // As per CSS\n      height: 50 // As per CSS\n    }));\n  }, []);\n  useEffect(() => {\n    // Key down handler\n    const handleKeyDown = e => {\n      keysPressed.current[e.code] = true;\n    };\n\n    // Key up handler\n    const handleKeyUp = e => {\n      keysPressed.current[e.code] = false;\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n\n    // Game loop\n    const gameLoop = setInterval(() => {\n      if (!isPaused) {\n        // Continuous Forward Movement\n        setLeftPosition(prev => {\n          const newPos = prev + forwardSpeed;\n          const maxLeft = gameBoardRef.current.clientWidth - 50; // 50 is the duckling width\n          return Math.min(newPos, maxLeft);\n        });\n\n        // Optional: Handle Left and Right Movements if desired\n        if (keysPressed.current['ArrowLeft'] || keysPressed.current['KeyA']) {\n          setLeftPosition(prev => Math.max(prev - moveSpeed, 0));\n          setFacingLeft(true);\n        }\n        if (keysPressed.current['ArrowRight'] || keysPressed.current['KeyD']) {\n          setLeftPosition(prev => Math.min(prev + moveSpeed, gameBoardRef.current.clientWidth - 50));\n          setFacingLeft(false);\n        }\n\n        // Jump\n        if ((keysPressed.current['Space'] || keysPressed.current['Spacebar']) && !isJumping) {\n          setIsJumping(true);\n          // Automatically reset jumping state after jumpDuration\n          setTimeout(() => {\n            setIsJumping(false);\n          }, jumpDuration);\n        }\n\n        // Check for landing on red block only when not jumping\n        if (!isJumping) {\n          const duckCenter = leftPosition + 25; // Duck's center x position (50px width)\n          const duckBlockIndex = Math.floor(duckCenter / 80); // blockWidth = 80px\n          if (duckBlockIndex >= 0 && duckBlockIndex < blocks.length && blocks[duckBlockIndex].type === 'red' && !duckOnRed) {\n            triggerMCQ();\n          }\n        }\n      }\n    }, 20); // Adjust game loop speed as needed\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n      clearInterval(gameLoop);\n    };\n  }, [isJumping, blocks, duckOnRed, isPaused]);\n  const triggerMCQ = () => {\n    // Select a random question\n    const randomIndex = Math.floor(Math.random() * questions.length);\n    setCurrentQuestion(questions[randomIndex]);\n    setShowMCQ(true);\n    setIsPaused(true); // Pause the game when MCQ is triggered\n    setDuckOnRed(true); // Prevent multiple triggers\n  };\n  const handleAnswer = isCorrect => {\n    if (isCorrect) {\n      setCoins(prevCoins => prevCoins + 1);\n      setScore(prevScore => prevScore + 10); // Increment score as desired\n      setIsPaused(false); // Resume movement\n    } else {\n      setLives(prevLives => {\n        const newLives = prevLives - 1;\n        if (newLives <= 0) {\n          // Trigger game over\n          onGameOver();\n        }\n        return newLives;\n      });\n      resetDuckling();\n      setIsPaused(false); // Resume movement after reset\n    }\n    setShowMCQ(false);\n    setDuckOnRed(false);\n  };\n  const resetDuckling = () => {\n    setLeftPosition(50); // Reset to starting position\n    // Optionally, reset other states or add effects\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-board\",\n    ref: gameBoardRef,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"platform\",\n      children: blocks.map((block, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `block ${block.type}`,\n        style: {\n          left: `${block.x}px`\n          // Other styles are handled by CSS\n        }\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 161,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Duckling, {\n      className: `${isJumping ? 'jumping' : ''} ${facingLeft ? 'facing-left' : ''}`,\n      style: {\n        left: `${leftPosition}px`,\n        transform: isJumping ? `translateY(-150px)` : 'translateY(0)'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 172,\n      columnNumber: 7\n    }, this), showMCQ && currentQuestion && /*#__PURE__*/_jsxDEV(MCQModal, {\n      questionData: currentQuestion,\n      onAnswer: handleAnswer\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 183,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 157,\n    columnNumber: 5\n  }, this);\n};\n_s(GameBoard, \"jXQ9ZH7AzF7Gc3aNv5F7mTavToA=\");\n_c = GameBoard;\nexport default GameBoard;\nvar _c;\n$RefreshReg$(_c, \"GameBoard\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useMemo","Duckling","MCQModal","questions","jsxDEV","_jsxDEV","GameBoard","setScore","setLives","setCoins","score","lives","coins","onGameOver","_s","gameBoardRef","leftPosition","setLeftPosition","isJumping","setIsJumping","facingLeft","setFacingLeft","isPaused","setIsPaused","forwardSpeed","moveSpeed","jumpDuration","showMCQ","setShowMCQ","currentQuestion","setCurrentQuestion","duckOnRed","setDuckOnRed","keysPressed","blocks","totalBlocks","Array","from","length","map","_","index","type","includes","x","y","width","height","handleKeyDown","e","current","code","handleKeyUp","window","addEventListener","gameLoop","setInterval","prev","newPos","maxLeft","clientWidth","Math","min","max","setTimeout","duckCenter","duckBlockIndex","floor","triggerMCQ","removeEventListener","clearInterval","randomIndex","random","handleAnswer","isCorrect","prevCoins","prevScore","prevLives","newLives","resetDuckling","className","ref","children","block","style","left","fileName","_jsxFileName","lineNumber","columnNumber","transform","questionData","onAnswer","_c","$RefreshReg$"],"sources":["E:/project/duckling-game/src/components/GameBoard.js"],"sourcesContent":["// src/components/GameBoard.js\r\n\r\nimport React, { useState, useEffect, useRef, useMemo } from 'react';\r\nimport './GameBoard.css';\r\nimport Duckling from './Duckling';\r\nimport MCQModal from './MCQModal';\r\nimport { questions } from '../data/questions'; // Ensure this path is correct\r\n\r\nconst GameBoard = ({\r\n  setScore,\r\n  setLives,\r\n  setCoins,\r\n  score,\r\n  lives,\r\n  coins,\r\n  onGameOver, // New prop to handle game over\r\n}) => {\r\n  const gameBoardRef = useRef(null);\r\n\r\n  // Duckling position states\r\n  const [leftPosition, setLeftPosition] = useState(50); // Initial left position in px\r\n  const [isJumping, setIsJumping] = useState(false);\r\n  const [facingLeft, setFacingLeft] = useState(false); // To handle orientation\r\n  const [isPaused, setIsPaused] = useState(false); // New state to control pause\r\n  const forwardSpeed = 2; // Continuous forward movement speed\r\n  const moveSpeed = 5; // Pixels to move per interval\r\n  const jumpDuration = 600; // Total jump duration in ms\r\n\r\n  // MCQ Modal states\r\n  const [showMCQ, setShowMCQ] = useState(false);\r\n  const [currentQuestion, setCurrentQuestion] = useState(null);\r\n  const [duckOnRed, setDuckOnRed] = useState(false);\r\n\r\n  // Key press state\r\n  const keysPressed = useRef({});\r\n\r\n  // Memoize blocks to prevent re-creation on every render\r\n  const blocks = useMemo(() => {\r\n    const totalBlocks = 20; // Number of blocks on the platform\r\n    return Array.from({ length: totalBlocks }).map((_, index) => ({\r\n      type: [4, 9, 14, 19].includes(index) ? 'red' : 'blue',\r\n      x: index * 80, // blockWidth is 80px as per CSS\r\n      y: 0, // Platforms are at y=0 relative to game board\r\n      width: 80, // As per CSS\r\n      height: 50, // As per CSS\r\n    }));\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Key down handler\r\n    const handleKeyDown = (e) => {\r\n      keysPressed.current[e.code] = true;\r\n    };\r\n\r\n    // Key up handler\r\n    const handleKeyUp = (e) => {\r\n      keysPressed.current[e.code] = false;\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    // Game loop\r\n    const gameLoop = setInterval(() => {\r\n      if (!isPaused) {\r\n        // Continuous Forward Movement\r\n        setLeftPosition((prev) => {\r\n          const newPos = prev + forwardSpeed;\r\n          const maxLeft = gameBoardRef.current.clientWidth - 50; // 50 is the duckling width\r\n          return Math.min(newPos, maxLeft);\r\n        });\r\n\r\n        // Optional: Handle Left and Right Movements if desired\r\n        if (keysPressed.current['ArrowLeft'] || keysPressed.current['KeyA']) {\r\n          setLeftPosition((prev) => Math.max(prev - moveSpeed, 0));\r\n          setFacingLeft(true);\r\n        }\r\n\r\n        if (keysPressed.current['ArrowRight'] || keysPressed.current['KeyD']) {\r\n          setLeftPosition((prev) =>\r\n            Math.min(prev + moveSpeed, gameBoardRef.current.clientWidth - 50)\r\n          );\r\n          setFacingLeft(false);\r\n        }\r\n\r\n        // Jump\r\n        if (\r\n          (keysPressed.current['Space'] || keysPressed.current['Spacebar']) &&\r\n          !isJumping\r\n        ) {\r\n          setIsJumping(true);\r\n          // Automatically reset jumping state after jumpDuration\r\n          setTimeout(() => {\r\n            setIsJumping(false);\r\n          }, jumpDuration);\r\n        }\r\n\r\n        // Check for landing on red block only when not jumping\r\n        if (!isJumping) {\r\n          const duckCenter = leftPosition + 25; // Duck's center x position (50px width)\r\n          const duckBlockIndex = Math.floor(duckCenter / 80); // blockWidth = 80px\r\n          if (\r\n            duckBlockIndex >= 0 &&\r\n            duckBlockIndex < blocks.length &&\r\n            blocks[duckBlockIndex].type === 'red' &&\r\n            !duckOnRed\r\n          ) {\r\n            triggerMCQ();\r\n          }\r\n        }\r\n      }\r\n    }, 20); // Adjust game loop speed as needed\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n      clearInterval(gameLoop);\r\n    };\r\n  }, [isJumping, blocks, duckOnRed, isPaused]);\r\n\r\n  const triggerMCQ = () => {\r\n    // Select a random question\r\n    const randomIndex = Math.floor(Math.random() * questions.length);\r\n    setCurrentQuestion(questions[randomIndex]);\r\n    setShowMCQ(true);\r\n    setIsPaused(true); // Pause the game when MCQ is triggered\r\n    setDuckOnRed(true); // Prevent multiple triggers\r\n  };\r\n\r\n  const handleAnswer = (isCorrect) => {\r\n    if (isCorrect) {\r\n      setCoins((prevCoins) => prevCoins + 1);\r\n      setScore((prevScore) => prevScore + 10); // Increment score as desired\r\n      setIsPaused(false); // Resume movement\r\n    } else {\r\n      setLives((prevLives) => {\r\n        const newLives = prevLives - 1;\r\n        if (newLives <= 0) {\r\n          // Trigger game over\r\n          onGameOver();\r\n        }\r\n        return newLives;\r\n      });\r\n      resetDuckling();\r\n      setIsPaused(false); // Resume movement after reset\r\n    }\r\n    setShowMCQ(false);\r\n    setDuckOnRed(false);\r\n  };\r\n\r\n  const resetDuckling = () => {\r\n    setLeftPosition(50); // Reset to starting position\r\n    // Optionally, reset other states or add effects\r\n  };\r\n\r\n  return (\r\n    <div className=\"game-board\" ref={gameBoardRef}>\r\n      {/* Platforms */}\r\n      <div className=\"platform\">\r\n        {blocks.map((block, index) => (\r\n          <div\r\n            key={index}\r\n            className={`block ${block.type}`}\r\n            style={{\r\n              left: `${block.x}px`,\r\n              // Other styles are handled by CSS\r\n            }}\r\n          ></div>\r\n        ))}\r\n      </div>\r\n      {/* Duckling */}\r\n      <Duckling\r\n        className={`${isJumping ? 'jumping' : ''} ${\r\n          facingLeft ? 'facing-left' : ''\r\n        }`}\r\n        style={{\r\n          left: `${leftPosition}px`,\r\n          transform: isJumping ? `translateY(-150px)` : 'translateY(0)',\r\n        }}\r\n      />\r\n      {/* MCQ Modal */}\r\n      {showMCQ && currentQuestion && (\r\n        <MCQModal questionData={currentQuestion} onAnswer={handleAnswer} />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GameBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}